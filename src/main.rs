use dotenv::dotenv;
use std::{
    env::{self},
    io::{self, BufRead},
};

mod chat_handler;
mod command_analyser;
mod llm;
mod prompts;
mod tmux_command_executor;
mod tools;
mod user_system_info;

use chat_handler::ChatHandler;
use llm::{LLMConfig, LLMError};

// args
const ARG_DEBUG: &str = "--debug_ask_sh";
const ARG_VERSION: &str = "--version";
const ARG_VERSION_SHORT: &str = "-v";

const ARG_STRINGS: &[&str] = &[ARG_DEBUG, ARG_VERSION, ARG_VERSION_SHORT];

// special arg
const ARG_INIT: &str = "--init";

// LLM provider settings
const ENV_LLM_PROVIDER: &str = "ASK_SH_LLM_PROVIDER";
const ENV_OPENAI_API_KEY: &str = "ASK_SH_OPENAI_API_KEY";
const ENV_OPENAI_MODEL: &str = "ASK_SH_OPENAI_MODEL";
const ENV_OPENAI_BASE_URL: &str = "ASK_SH_OPENAI_BASE_URL";
const ENV_ANTHROPIC_API_KEY: &str = "ASK_SH_ANTHROPIC_API_KEY";
const ENV_ANTHROPIC_MODEL: &str = "ASK_SH_ANTHROPIC_MODEL";
const ENV_OLLAMA_BASE_URL: &str = "ASK_SH_OLLAMA_BASE_URL";
const ENV_OLLAMA_MODEL: &str = "ASK_SH_OLLAMA_MODEL";
const ENV_OLLAMA_KEEP_ALIVE: &str = "ASK_SH_OLLAMA_KEEP_ALIVE";
const ENV_OLLAMA_CONTEXT_LENGTH: &str = "ASK_SH_OLLAMA_CONTEXT_LENGTH";
const ENV_SEARXNG_BASE_URL: &str = "ASK_SH_SEARXNG_BASE_URL";

fn get_llm_config() -> Result<LLMConfig, LLMError> {
    // Select provider (default is OpenAI)
    let provider = env::var(ENV_LLM_PROVIDER).unwrap_or_else(|_| "openai".to_string());

    match provider.as_str() {
        "openai" => {
            let api_key = env::var(ENV_OPENAI_API_KEY)
                .map_err(|_| LLMError::ConfigError("OpenAI API key not found".to_string()))?;

            let model = env::var(ENV_OPENAI_MODEL).unwrap_or_else(|_| "gpt-3.5-turbo".to_string());

            let base_url = env::var(ENV_OPENAI_BASE_URL).ok();

            Ok(LLMConfig {
                provider,
                api_key,
                model,
                base_url,
                keep_alive: None,
                context_length: None,
                tools: None, // Some(tools::get_available_tools()),
            })
        }
        "anthropic" => {
            let api_key = env::var(ENV_ANTHROPIC_API_KEY)
                .map_err(|_| LLMError::ConfigError("Anthropic API key not found".to_string()))?;

            let model = env::var(ENV_ANTHROPIC_MODEL)
                .unwrap_or_else(|_| "claude-3-5-sonnet-latest".to_string());

            Ok(LLMConfig {
                provider,
                api_key,
                model,
                base_url: None, // Anthropic does not support custom endpoints
                keep_alive: None,
                context_length: None,
                tools: Some(tools::get_available_tools()),
            })
        }
        "ollama" => {
            let api_key = "ollama dummy key".to_string();

            let model = env::var(ENV_OLLAMA_MODEL).unwrap_or_else(|_| "gemma3:4b".to_string());

            let base_url = env::var(ENV_OLLAMA_BASE_URL).ok();

            let keep_alive: Option<i32> = env::var(ENV_OLLAMA_KEEP_ALIVE)
                .ok()
                .and_then(|s| s.parse().ok());

            let context_length: Option<u32> = env::var(ENV_OLLAMA_CONTEXT_LENGTH)
                .ok()
                .and_then(|s| s.parse().ok());

            Ok(LLMConfig {
                provider,
                api_key,
                model,
                base_url,
                keep_alive,
                context_length,
                tools: Some(tools::get_available_tools()),
            })
        }
        _ => Err(LLMError::ConfigError(format!(
            "Unknown provider: {}",
            provider
        ))),
    }
}

fn print_init_script() {
    print!(
        r#"# This function is automatically generated by ask-sh --init
# ask.sh shell function v2
ask() {{
    if ! command -v ask-sh &> /dev/null; then
        printf "‚ùå Necessary rust package ask-sh is installed but cannot be accessed. Rust's bin path may not be added to your PATH."
        printf "üëâ It's usually under ~/.cargo/bin/"
        printf "üëÄ Please add it to your PATH and restart your shell."
    fi
    suggested_commands=`echo "$@" | ask-sh 2> >(cat 1>&2)`
    if [ -n "$suggested_commands" ]; then
        printf "\n" # add one empty line to create space
        printf "üëã Hey, AI has suggested some commands that can be typed into your terminal.\n"
        printf "üîç Press Enter to view and select the commands, or type any other key to exit:"
        if [ -n "$ZSH_VERSION" ]; then # read a single char
            read -r -k 1 REPLY # zsh
        else
            read -r -n 1 REPLY # bash
        fi
        REPLY="${{REPLY#"${{REPLY%%[![:space:]]*}}"}}"  # trim whitespaces
        if [ -z "$REPLY" ] ; then
            # As Enter will move cursor to the next line, we need to go back two lines
            printf "\033[2A"
            # \033[2K: delete current line (üëã line), \n: go next line, \033[2K: delete next line (üîç line)
            printf "\033[2K\n\033[2K\n"
            # We're at the emptified üîç line. So, go back two lines, including empty line to make space
            printf "\033[2A" # go back again
            selected_command=`echo "$suggested_commands" | peco  --prompt "AI suggested commands (Enter to use / Ctrl+C to exit):"`
            if [ -n "$selected_command" ]; then
                if ! print -z $selected_command 2>/dev/null; then
                    history -s $selected_command
                fi
            fi
        else
            # We're at the end of üîç line. So, go back one line (üëã line)
            printf "\033[1A"
            printf "\033[2K\n\033[2K\n"
            printf "\033[2A"
        fi
    fi
    if [ -z "$ASK_SH_NO_UPDATE" ]; then
        latest_version=`cargo search ask-sh | grep ask-sh | awk '{{print $3}}' | cut -d '"' -f2`
        current_version=`ask-sh --version`
        if [ "$(printf '%s\n' "$latest_version" "$current_version" | sort -rV | head -n1)" = "$latest_version" ] && [ "$latest_version" != "$current_version" ]; then
            # clear line
            printf "\n"
            printf "üéâ New version of ask-sh is available! (Current: $current_version vs New: $latest_version) Set \$ASK_SH_NO_UPDATE=1 to suppress this notice.\n"
            printf "üÜô Press Enter to run update now, or type any other key to exit:"
            if [ -n "$ZSH_VERSION" ]; then # read a single char
                read -r -k 1 REPLY # zsh
            else
                read -r -n 1 REPLY # bash
            fi
            REPLY="${{REPLY#"${{REPLY%%[![:space:]]*}}"}}"  # trim whitespaces
            if [ -z "$REPLY" ] ; then
                cargo install --force ask-sh
                printf "\nDone! Please restart your shell or source ~/.zshrc or ~/.bashrc etc... to use the new version.\n"
            else
                printf "\nOk, you can update ask-sh later by running 'cargo install --force ask-sh'.\n"
            fi
        fi
    fi
}}
"#
    );
}

#[tokio::main]
async fn main() {
    dotenv().ok();

    // if called with only --init, the command emits a shell script to be sourced
    if env::args().len() == 2 && env::args().nth(1).unwrap() == ARG_INIT {
        print_init_script();
        return;
    }

    // if called with only --version or -v, print version and exit
    if env::args().len() == 2 {
        let arg = env::args().nth(1).unwrap();
        if arg == ARG_VERSION || arg == ARG_VERSION_SHORT {
            println!("{}", env!("CARGO_PKG_VERSION"));
            return;
        }
    }

    // check input from users
    // arg without the first executable name
    let args: Vec<String> = env::args().skip(1).collect();
    // check if args are all predefined args
    let is_using_stdin = args.iter().all(|arg| ARG_STRINGS.contains(&arg.as_str()));

    let user_input = if is_using_stdin {
        io::stdin().lock().lines().next().unwrap().unwrap()
    } else {
        args.join(" ")
    };

    println!("");

    // filter out predefined args
    let user_input_without_flags = user_input
        .split_whitespace()
        .filter(|arg| !ARG_STRINGS.contains(arg))
        .collect::<Vec<&str>>()
        .join(" ");

    let llm_config = get_llm_config().unwrap();
    let mut chat_handler = ChatHandler::new(llm_config);
    chat_handler
        .process_user_prompt(user_input_without_flags)
        .await;
}
